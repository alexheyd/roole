#!/usr/bin/env node

var path = require('path');
var fs = require('fs-extra');
var program = require('commander');
var chokidar = require('chokidar');
var roole = require('..');
var ver = require('../package.json').version;

program
	.version(ver, '-v, --version')
	.usage('[options] [file|dir ...]')
	.option('-s, --stdout', 'Output compiled CSS to stdout')
	.option('-o, --out <dir>', 'Write compiled files to <dir>')
	.option('-w, --watch', 'Watch files and re-compile if changed')
	.option('-f, --force', 'Create files even when compile to empty string')
	.option('    --prefixes <names>', 'comma-separated vendor names to use for prefixing')
	.option('    --indent <str>', 'Indentation string to use in CSS')
	.option('    --precision <num>', 'Max number of decimal digits to use in CSS', parseInt)
	.option('    --skip-prefixed', 'Not generate prefixed rule that already exists')
	.parse(process.argv);

if (!program.args.length) {
	var stdin = '';
	process.stdin.resume();
	process.stdin.setEncoding('utf8');
	process.stdin.on('data', function(chunk) { stdin += chunk; });
	process.stdin.on('end', function(){
		roole.compile(stdin, program, function (err, css) {
			if (err) throw err;
			process.stdout.write(css);
		});
	});
	return;
}

program.args.forEach(function (arg) {
	if (!program.stdout && program.watch) console.log('  watching %s', arg);

	resolve(arg, function (filename) {
		var opts = Object.create(program);
		opts.prettyError = true;

		compileFile(filename, opts, function (err, css) {
			if (err) throw err;

			if (program.stdout) {
				if (css) process.stdout.write(css);
				return;
			}

			if (!css && !program.force && !program.watch) {
				console.log('INFO: %d compiled to empty string, not writing to file', file.input.name);
				return;
			}

			var out;
			if (program.out) {
				if (arg === filename) {
					var base = path.basename(filename);
					out =  path.resolve(program.out, base);
				} else {
					var sub = path.relative(arg, filename);
					out = path.resolve(program.out, sub);
				}
			} else {
				out = filename;
			}
			out = out.replace(/(\.roo)?$/, '.css');
			fs.createFileSync(out);

			if (css || program.force) fs.writeFileSync(out, css);

			if (program.watch) {
				var imports = Object.keys(opts.imports);

				watch(filename, imports, out);
			}
		});
	});
});

function resolve(filename, cb, rooOnly) {
	fs.stat(filename, function (err, stats) {
		if (err) throw err;
		if (stats.isFile()) {
			if (rooOnly && path.extname(filename) !== '.roo') return;
			return cb(filename);
		}
		if (!stats.isDirectory()) return;

		fs.readdir(filename, function (err, bases) {
			if (err) throw err;

			bases.forEach(function (base) {
				resolve(path.resolve(filename, base), cb, true);
			});
		});
	});
}

function compileFile(filename, opts, cb) {
	if (!cb) {
		cb = opts;
		opts = { prettyError: true }
	}
	fs.readFile(filename, 'utf8', function (err, data) {
		if (err) return cb(err);

		opts.filename = filename;
		roole.compile(data, opts, cb);
	});
}

function watch(filename, imports, out) {
	imports.push(filename);

	imports.forEach(function (imp) {
		var watcher = chokidar.watch(imp, { persistent: true });
		watcher.on('change', function () {
			compileFile(filename, function (err, css) {
				if (err) {
					console.error('%s: %s', err.name, err.message);
					return;
				}

				if (!css) {
					console.log('  %s compiled to empty string, not writing to file', filename);
					return;
				}

				fs.writeFileSync(out, css);
				console.log('  compiled %s to %s', filename, out);
			});
		});
	});
}
#!/usr/bin/env node

var path = require('path');
var fs = require('fs-extra');
var program = require('commander');
var chokidar = require('chokidar');
var roole = require('..');
var ver = require('../package.json').version;

program
	.version(ver, '-v, --version')
	.usage('[options] [file|dir ...]')
	.option('-s, --stdout', 'Output compiled CSS to stdout')
	.option('-o, --out <dir>', 'Write compiled files to <dir>')
	.option('-w, --watch', 'Watch files and re-compile if changed')
	.option('-f, --force', 'Create files even when compile to empty string')
	.option('    --prefixes <names>', 'comma-separated vendor names to use for prefixing')
	.option('    --indent <str>', 'Indentation string to use in CSS')
	.option('    --precision <num>', 'Max number of decimal digits to use in CSS', parseInt)
	.option('    --skip-prefixed', 'Not generate prefixed rule that already exists')
	.parse(process.argv);

program.errorContextIndent = '    ';

if (!program.args.length) {
	var stdin = '';
	process.stdin.resume();
	process.stdin.setEncoding('utf8');
	process.stdin.on('data', function(chunk) { stdin += chunk; });
	process.stdin.on('end', function(){
		program.filename = process.cwd() + '/';
		if (!program.out) program.out = process.cwd();

		roole.compile(stdin, program, function (err, css) {
			if (err) exitWithError(err);
			process.stdout.write(css);
		});
	});
	return;
}

program.args.forEach(function (arg) {
	if (!program.stdout && program.watch) console.log('  watching %s', arg);

	resolve(arg, function (filename) {
		var cssname;
		if (program.out) {
			if (arg === filename) {
				var base = path.basename(filename);
				cssname =  path.resolve(program.out, base);
			} else {
				var sub = path.relative(arg, filename);
				cssname = path.resolve(program.out, sub);
			}
		} else {
			cssname = filename;
		}
		cssname = cssname.replace(/(\.roo)?$/, '.css');
		var out = path.dirname(cssname);

		var opts = Object.create(program);
		opts.out = out

		compileFile(filename, opts, function (err, css) {
			if (err) exitWithError(err);

			if (program.stdout) {
				if (css) process.stdout.write(css);
				return;
			}

			if (!css && !program.force && !program.watch) {
				console.log('INFO: %d compiled to empty string, not writing to file', filename);
				return;
			}

			fs.createFileSync(cssname);

			if (css || program.force) fs.writeFileSync(cssname, css);

			if (program.watch) {
				var imports = Object.keys(opts.imports);

				watch(filename, imports, cssname);
			}
		});
	});
});

function resolve(filename, cb, rooOnly) {
	fs.stat(filename, function (err, stats) {
		if (err) throw err;
		if (stats.isFile()) {
			if (rooOnly && path.extname(filename) !== '.roo') return;
			return cb(filename);
		}
		if (!stats.isDirectory()) return;

		fs.readdir(filename, function (err, bases) {
			if (err) throw err;

			bases.forEach(function (base) {
				resolve(path.resolve(filename, base), cb, true);
			});
		});
	});
}

function compileFile(filename, opts, cb) {
	fs.readFile(filename, 'utf8', function (err, data) {
		if (err) return cb(err);

		opts.filename = filename;
		roole.compile(data, opts, cb);
	});
}

function watch(filename, imports, cssname) {
	imports.push(filename);

	var out = path.dirname(cssname);
	imports.forEach(function (imp) {
		var watcher = chokidar.watch(imp, { persistent: true });
		watcher.on('change', function () {
			var opts = {
				prettyError: true,
				out: out
			};
			compileFile(filename, opts, function (err, css) {
				if (err) {
					displayError(err);
					return;
				}

				watcher.add(Object.keys(opts.imports));

				if (!css) {
					console.log('  %s compiled to empty string, not writing to file', filename);
					return;
				}

				fs.writeFileSync(cssname, css);
				console.log('  compiled %s to %s', filename, cssname);
			});
		});
	});
}

function exitWithError(err) {
	if (!err.loc) throw err;

	displayError(err);
	process.exit(1);
}

function displayError(err) {
	if (!err.loc) {
		console.err(err.toString());
		return;
	}

	console.error(err.loc.filename + ':' + err.loc.line + ':' + err.loc.column + '\n');
	console.error(err.toString() + '\n');
	console.error(err.context);
}